c#  forms 

using System;
using System.Drawing;
using System.Windows.Forms;

public class MapForm : Form
{
    private int[,] map =
    {
        { 0, 1, 0, 0, 2 },
        { 1, 1, 0, 2, 2 },
        { 0, 0, 0, 2, 1 },
        { 0, 2, 2, 1, 0 }
    };

    private int tileSize = 40;

    public MapForm()
    {
        this.Text = "2D åœ°åœ–ç¯„ä¾‹";
        this.Size = new Size(300, 300);
        this.DoubleBuffered = true; // é¿å…é–ƒçˆ
    }

    protected override void OnPaint(PaintEventArgs e)
    {
        Graphics g = e.Graphics;

        for (int y = 0; y < map.GetLength(0); y++)
        {
            for (int x = 0; x < map.GetLength(1); x++)
            {
                Color color = GetTileColor(map[y, x]);
                using (Brush brush = new SolidBrush(color))
                {
                    g.FillRectangle(brush, x * tileSize, y * tileSize, tileSize, tileSize);
                    g.DrawRectangle(Pens.Black, x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }
        }
    }

    private Color GetTileColor(int tileType)
    {
        return tileType switch
        {
            0 => Color.LightGreen, // è‰åœ°
            1 => Color.Gray,       // çŸ³é ­
            2 => Color.Blue,       // æ°´
            _ => Color.White
        };
    }

    [STAThread]
    public static void Main()
    {
        Application.Run(new MapForm());
    }
}
--------------------------------------------------------------------------------------------------
c# console

using System;
using System.Collections.Generic;

class MazeGenerator
{
    const int width = 21;  // å¿…é ˆç‚ºå¥‡æ•¸
    const int height = 21; // å¿…é ˆç‚ºå¥‡æ•¸

    static int[,] maze = new int[height, width];
    static Random rand = new Random();

    static void Main()
    {
        GenerateMaze(1, 1);
        PrintMaze();
        Console.WriteLine("\nè¿·å®®ç”Ÿæˆå®Œæˆï¼æŒ‰ä»»æ„éµçµæŸ...");
        Console.ReadKey();
    }

    static void GenerateMaze(int x, int y)
    {
        maze[y, x] = 1; // æ¨™è¨˜ç‚ºé€šé“

        int[] dirs = { 0, 1, 2, 3 };
        Shuffle(dirs); // éš¨æ©Ÿæ–¹å‘

        foreach (int dir in dirs)
        {
            int dx = 0, dy = 0;
            switch (dir)
            {
                case 0: dx = 0; dy = -1; break; // ä¸Š
                case 1: dx = 1; dy = 0; break;  // å³
                case 2: dx = 0; dy = 1; break;  // ä¸‹
                case 3: dx = -1; dy = 0; break; // å·¦
            }

            int nx = x + dx * 2;
            int ny = y + dy * 2;

            if (InBounds(nx, ny) && maze[ny, nx] == 0)
            {
                maze[y + dy, x + dx] = 1; // æ‰“é€šç‰†å£
                GenerateMaze(nx, ny);     // éè¿´
            }
        }
    }

    static void Shuffle(int[] array)
    {
        for (int i = array.Length - 1; i > 0; i--)
        {
            int j = rand.Next(i + 1);
            (array[i], array[j]) = (array[j], array[i]);
        }
    }

    static bool InBounds(int x, int y)
    {
        return x > 0 && x < width - 1 && y > 0 && y < height - 1;
    }

    static void PrintMaze()
    {
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (maze[y, x] == 1)
                {
                    Console.Write("  "); // é€šé“ = ç©ºç™½
                }
                else
                {
                    Console.Write("##"); // ç‰†å£
                }
            }
            Console.WriteLine();
        }
    }
}
----------------------------------------------------------------------------
c# start and end

using System;
using System.Collections.Generic;

class MazeGenerator
{
    const int width = 21;  // å¿…é ˆç‚ºå¥‡æ•¸
    const int height = 21; // å¿…é ˆç‚ºå¥‡æ•¸

    static int[,] maze = new int[height, width];
    static Random rand = new Random();

    static void Main()
    {
        GenerateMaze(1, 1);

        // âœ… è¨­å®šå‡ºå…¥å£
        maze[1, 0] = 1;                    // å…¥å£ï¼ˆå·¦é‚Šé‚Šç•Œé–‹å£ï¼‰
        maze[height - 2, width - 1] = 1;   // å‡ºå£ï¼ˆå³é‚Šé‚Šç•Œé–‹å£ï¼‰

        PrintMaze();

        Console.WriteLine("\nå…¥å£: (1,0)   å‡ºå£: ({0},{1})", height - 2, width - 1);
        Console.WriteLine("è¿·å®®ç”Ÿæˆå®Œæˆï¼æŒ‰ä»»æ„éµçµæŸ...");
        Console.ReadKey();
    }

    static void GenerateMaze(int x, int y)
    {
        maze[y, x] = 1; // æ¨™è¨˜ç‚ºé€šé“

        int[] dirs = { 0, 1, 2, 3 };
        Shuffle(dirs); // éš¨æ©Ÿæ–¹å‘

        foreach (int dir in dirs)
        {
            int dx = 0, dy = 0;
            switch (dir)
            {
                case 0: dx = 0; dy = -1; break; // ä¸Š
                case 1: dx = 1; dy = 0; break;  // å³
                case 2: dx = 0; dy = 1; break;  // ä¸‹
                case 3: dx = -1; dy = 0; break; // å·¦
            }

            int nx = x + dx * 2;
            int ny = y + dy * 2;

            if (InBounds(nx, ny) && maze[ny, nx] == 0)
            {
                maze[y + dy, x + dx] = 1; // æ‰“é€šç‰†å£
                GenerateMaze(nx, ny);     // éè¿´
            }
        }
    }

    static void Shuffle(int[] array)
    {
        for (int i = array.Length - 1; i > 0; i--)
        {
            int j = rand.Next(i + 1);
            (array[i], array[j]) = (array[j], array[i]);
        }
    }

    static bool InBounds(int x, int y)
    {
        return x > 0 && x < width - 1 && y > 0 && y < height - 1;
    }

    static void PrintMaze()
    {
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if (maze[y, x] == 1)
                {
                    Console.Write("  "); // é€šé“ = ç©ºç™½
                }
                else
                {
                    Console.Write("##"); // ç‰†å£
                }
            }
            Console.WriteLine();
        }
    }
}


--------------------------------------------------------------------------------
c# åœ°åœ– å°‹æ‰¾ æ–¹å¼

using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;

class AnimatedBFS
{
    const int width = 21;
    const int height = 21;
    static int[,] maze = new int[height, width];
    static Random rand = new Random();

    static (int y, int x) start = (1, 0);
    static (int y, int x) goal = (height - 2, width - 1);

    static void Main()
    {
        Console.OutputEncoding = Encoding.UTF8;
        Console.CursorVisible = false;

        GenerateMaze(1, 1);
        maze[start.y, start.x] = 1;
        maze[goal.y, goal.x] = 1;

        PrintMaze();

        Console.SetCursorPosition(0, height + 1);
        Console.WriteLine("ğŸ” æ­£åœ¨æ¢ç´¢è¿·å®®ä¸­...");
        SolveMazeWithBFS_Animated(start, goal);

        Console.SetCursorPosition(0, height + 3);
        Console.WriteLine("âœ… è§£è¿·å®®å®Œæˆï¼æŒ‰ä»»æ„éµçµæŸ...");
        Console.ReadKey();
    }

    static void SolveMazeWithBFS_Animated((int y, int x) start, (int y, int x) goal)
    {
        var queue = new Queue<(int y, int x)>();
        var visited = new bool[height, width];
        var prev = new (int y, int x)?[height, width];

        queue.Enqueue(start);
        visited[start.y, start.x] = true;

        int[] dx = { 0, 1, 0, -1 };
        int[] dy = { -1, 0, 1, 0 };

        while (queue.Count > 0)
        {
            var (cy, cx) = queue.Dequeue();

            if ((cy, cx) != start && (cy, cx) != goal)
                DrawAt(cx, cy, 'â–’', ConsoleColor.DarkCyan); // æ¢ç´¢ç¯€é»å‹•ç•«

            Thread.Sleep(20); // å‹•ç•«å»¶é²

            if ((cy, cx) == goal)
            {
                // å›æº¯è·¯å¾‘
                var current = goal;
                while (current != start)
                {
                    var p = prev[current.y, current.x];
                    if (p != null && p != start)
                        DrawAt(p.Value.x, p.Value.y, 'â—', ConsoleColor.Yellow); // æ¨™è¨˜è·¯å¾‘
                    current = p.Value;
                    Thread.Sleep(15);
                }

                DrawAt(start.x, start.y, 'S', ConsoleColor.Green);
                DrawAt(goal.x, goal.y, 'G', ConsoleColor.Red);
                return;
            }

            for (int i = 0; i < 4; i++)
            {
                int nx = cx + dx[i];
                int ny = cy + dy[i];

                if (InBounds(nx, ny) && !visited[ny, nx] && maze[ny, nx] == 1)
                {
                    queue.Enqueue((ny, nx));
                    visited[ny, nx] = true;
                    prev[ny, nx] = (cy, cx);
                }
            }
        }

        Console.WriteLine("âŒ ç„¡æ³•æ‰¾åˆ°å‡ºå£ï¼");
    }

    static void DrawAt(int x, int y, char symbol, ConsoleColor color)
    {
        Console.SetCursorPosition(x * 2, y); // *2 è®“æ ¼å­å¯¬ä¸€é»
        Console.ForegroundColor = color;
        Console.Write(symbol + " ");
        Console.ResetColor();
    }

    static void GenerateMaze(int x, int y)
    {
        maze[y, x] = 1;
        int[] dirs = { 0, 1, 2, 3 };
        Shuffle(dirs);

        foreach (int dir in dirs)
        {
            int dx = 0, dy = 0;
            switch (dir)
            {
                case 0: dx = 0; dy = -1; break;
                case 1: dx = 1; dy = 0; break;
                case 2: dx = 0; dy = 1; break;
                case 3: dx = -1; dy = 0; break;
            }

            int nx = x + dx * 2;
            int ny = y + dy * 2;

            if (InBounds(nx, ny) && maze[ny, nx] == 0)
            {
                maze[y + dy, x + dx] = 1;
                GenerateMaze(nx, ny);
            }
        }
    }

    static void Shuffle(int[] array)
    {
        for (int i = array.Length - 1; i > 0; i--)
        {
            int j = rand.Next(i + 1);
            (array[i], array[j]) = (array[j], array[i]);
        }
    }

    static bool InBounds(int x, int y)
    {
        return x >= 0 && x < width && y >= 0 && y < height;
    }

    static void PrintMaze()
    {
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if ((y, x) == start)
                    Console.Write("S ");
                else if ((y, x) == goal)
                    Console.Write("G ");
                else if (maze[y, x] == 0)
                    Console.Write("â–ˆâ–ˆ");
                else
                    Console.Write("  ");
            }
            Console.WriteLine();
        }
    }
}
-------------------------------------------------------------------
c# åœ°åœ– å„ªåŒ–

â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ
S â—    â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â—                  â–ˆ
â–ˆ â–ˆ â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ â—    â–ˆ â–ˆ â–ˆ   â–ˆ
â–ˆ â–‘ â–ˆ â—          â–‘ â–ˆ â—    â–‘ â–ˆ â—â—â—        â–ˆ   â–ˆ
â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â—  â–ˆ â–ˆ â—  â–ˆ â–ˆ â–‘ â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ   â–ˆ   â–ˆ
â–ˆ â–‘ â–‘ â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ â–‘ â–ˆ â—      â—â—â—â—â—            â–ˆ   â–ˆ
â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ   â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ
â–ˆ â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–ˆ â—â—â—  â—                â–ˆ
â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â—  â–ˆ â–ˆ â—  â–ˆ â–ˆ â—    â–ˆ â–ˆ â–ˆ   â–ˆ
â–ˆ â–‘ â–‘ â–‘ â–‘ â–‘ â–ˆ â–‘ â–ˆ â—â—â—  â–‘ â–ˆ â—      â—â—â—        â–ˆ   â–ˆ
â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â—  â—  â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ   â–ˆ   â–ˆ
â–ˆ â–‘ â–‘ â–‘ â–‘ â–‘ â–ˆ â–‘ â–ˆ â—  â—â—â—â—â—  â–‘ â–‘ â–‘ â–ˆ â—            â–ˆ   â–ˆ
â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ   â–ˆ
â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â—â—â—  â–‘ â–‘ â–‘ â–ˆ â—â—â—â—â—â—â—  â—        â–ˆ
â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â—  â–ˆ â–ˆ â—  â–‘ â–ˆ
â–ˆ â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ â—  â—        â–‘ â–‘ â—    â—â—â—  â—  â–‘ â–ˆ
â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â—  â—  â–ˆ â–ˆ â–ˆ â–ˆ â—  â–‘ â–ˆ â—  â—  â–ˆ â–ˆ â—  â—  â–‘ â–ˆ
â–ˆ â—â—â—â—â—â—â—  â—  â–‘ â–‘ â–‘ â–ˆ â—  â–‘ â–ˆ â—  â—      â—
â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â—  â–‘ â–ˆ â–ˆ â–ˆ â—  â–ˆ â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â—
â–ˆ â—          â–‘ â–‘ â–‘ â–‘ â—                      â—G
â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ

ğŸ” æ­£åœ¨åŸ·è¡Œ BFS æ¢ç´¢è¿·å®®...

âœ… æ¢ç´¢å®Œæˆï¼ç¸½å…±æ¢ç´¢æ ¼æ•¸ï¼š252
â±ï¸ è€—æ™‚ï¼š6927 æ¯«ç§’
ğŸ”š æŒ‰ä»»æ„éµçµæŸ...

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Threading;

class AnimatedBFSWithStats
{
    const int width = 31;
    const int height = 21;
    static int[,] maze = new int[height, width];
    static Random rand = new Random();

    static (int y, int x) start = (1, 0);
    static (int y, int x) goal = (height - 2, width - 1);

    static void Main()
    {
        Console.OutputEncoding = Encoding.UTF8;
        Console.CursorVisible = false;

        GenerateMaze(1, 1);
        maze[start.y, start.x] = 1;
        maze[goal.y, goal.x] = 1;

        PrintMaze();

        Console.SetCursorPosition(0, height + 1);
        Console.WriteLine("ğŸ” æ­£åœ¨åŸ·è¡Œ BFS æ¢ç´¢è¿·å®®...");

        var sw = Stopwatch.StartNew();
        int steps = SolveMazeWithBFS_Animated(start, goal);
        sw.Stop();

        Console.SetCursorPosition(0, height + 3);
        Console.WriteLine($"âœ… æ¢ç´¢å®Œæˆï¼ç¸½å…±æ¢ç´¢æ ¼æ•¸ï¼š{steps}");
        Console.WriteLine($"â±ï¸ è€—æ™‚ï¼š{sw.ElapsedMilliseconds} æ¯«ç§’");
        Console.WriteLine("ğŸ”š æŒ‰ä»»æ„éµçµæŸ...");
        Console.ReadKey();
    }

    static int SolveMazeWithBFS_Animated((int y, int x) start, (int y, int x) goal)
    {
        var queue = new Queue<(int y, int x)>();
        var visited = new bool[height, width];
        var prev = new (int y, int x)?[height, width];

        queue.Enqueue(start);
        visited[start.y, start.x] = true;

        int[] dx = { 0, 1, 0, -1 };
        int[] dy = { -1, 0, 1, 0 };

        int stepCount = 0;

        while (queue.Count > 0)
        {
            var (cy, cx) = queue.Dequeue();
            stepCount++;

            if ((cy, cx) != start && (cy, cx) != goal)
                DrawAt(cx, cy, 'â–‘', ConsoleColor.Gray); // æ¢ç´¢ç¯€é»å‹•ç•«

            Thread.Sleep(10); // æ§åˆ¶å‹•ç•«é€Ÿåº¦

            if ((cy, cx) == goal)
            {
                var current = goal;
                while (current != start)
                {
                    var p = prev[current.y, current.x];
                    if (p != null && p != start)
                        DrawAt(p.Value.x, p.Value.y, 'â—', ConsoleColor.Yellow); // æ¨™è¨˜æœ€çŸ­è·¯å¾‘
                    current = p.Value;
                    Thread.Sleep(5); // æ›´å¿«é¡¯ç¤ºæœ€çŸ­è·¯å¾‘
                }

                DrawAt(start.x, start.y, 'S', ConsoleColor.Green);
                DrawAt(goal.x, goal.y, 'G', ConsoleColor.Red);
                return stepCount;
            }

            for (int i = 0; i < 4; i++)
            {
                int nx = cx + dx[i];
                int ny = cy + dy[i];

                if (InBounds(nx, ny) && !visited[ny, nx] && maze[ny, nx] == 1)
                {
                    queue.Enqueue((ny, nx));
                    visited[ny, nx] = true;
                    prev[ny, nx] = (cy, cx);
                }
            }
        }

        Console.WriteLine("âŒ ç„¡æ³•æ‰¾åˆ°å‡ºå£ï¼");
        return stepCount;
    }

    static void DrawAt(int x, int y, char symbol, ConsoleColor color)
    {
        Console.SetCursorPosition(x * 2, y);
        Console.ForegroundColor = color;
        Console.Write(symbol + " ");
        Console.ResetColor();
    }

    static void GenerateMaze(int x, int y)
    {
        maze[y, x] = 1;
        int[] dirs = { 0, 1, 2, 3 };
        Shuffle(dirs);

        foreach (int dir in dirs)
        {
            int dx = 0, dy = 0;
            switch (dir)
            {
                case 0: dx = 0; dy = -1; break;
                case 1: dx = 1; dy = 0; break;
                case 2: dx = 0; dy = 1; break;
                case 3: dx = -1; dy = 0; break;
            }

            int nx = x + dx * 2;
            int ny = y + dy * 2;

            if (InBounds(nx, ny) && maze[ny, nx] == 0)
            {
                maze[y + dy, x + dx] = 1;
                GenerateMaze(nx, ny);
            }
        }
    }

    static void Shuffle(int[] array)
    {
        for (int i = array.Length - 1; i > 0; i--)
        {
            int j = rand.Next(i + 1);
            (array[i], array[j]) = (array[j], array[i]);
        }
    }

    static bool InBounds(int x, int y)
    {
        return x >= 0 && x < width && y >= 0 && y < height;
    }

    static void PrintMaze()
    {
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if ((y, x) == start)
                {
                    Console.ForegroundColor = ConsoleColor.Green;
                    Console.Write("S ");
                    Console.ResetColor();
                }
                else if ((y, x) == goal)
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.Write("G ");
                    Console.ResetColor();
                }
                else if (maze[y, x] == 0)
                {
                    Console.ForegroundColor = ConsoleColor.DarkGray;
                    Console.Write("â–ˆ ");
                    Console.ResetColor();
                }
                else
                {
                    Console.Write("  ");
                }
            }
            Console.WriteLine();
        }
    }
}

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ç¨‹å¼å•Ÿå‹•           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      åˆå§‹åŒ–è¿·å®®é™£åˆ—         â”‚
â”‚ï¼ˆå…¨éƒ¨è¨­ç‚ºç‰† maze[y,x] = 0ï¼‰ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ä½¿ç”¨éè¿´å›æº¯æ³•ç”¢ç”Ÿè¿·å®®    â”‚
â”‚   (GenerateMaze å‡½å¼)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     è¨­å®šèµ·é» (S) èˆ‡çµ‚é»(G)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        é¡¯ç¤ºåˆå§‹è¿·å®®         â”‚
â”‚     (ç‰†=â–ˆ, è·¯=ç©ºç™½)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    åˆå§‹åŒ– BFS è³‡æ–™çµæ§‹      â”‚
â”‚  Queue, visited[], prev[]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          é–‹å§‹ BFS æ¢ç´¢     â”‚
â”‚   å¾ queue æ‹¿å‡ºç¯€é» (y,x)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ˜¯å¦ç‚ºç›®æ¨™é» Gï¼Ÿ            â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
      â”‚ å¦          â”‚ æ˜¯                   â”‚
      â–¼             â–¼                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ æ¢ç´¢é„°è¿‘ç¯€é»    â”‚  â”‚ é–‹å§‹å›æº¯ prev[][]  â”‚ â”‚
â”‚ ä¸¦æ¨™è¨˜ visited  â”‚  â”‚ ç•«å‡ºæœ€çŸ­è·¯å¾‘ â—      â”‚ â”‚
â”‚ å‹•ç•«é¡¯ç¤º â–‘      â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚         â”‚
       â”‚                         â–¼         â”‚
       â””â”€â”€â”€â”€â”€> å›åˆ° BFS ä¸»è¿´åœˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             ï¼ˆç›´åˆ°æ‰¾åˆ°æˆ– queue ç©ºï¼‰

             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é¡¯ç¤ºçµ±è¨ˆè³‡è¨Šï¼š             â”‚
â”‚ æ¢ç´¢æ¬¡æ•¸ / ç¸½è€—æ™‚(ms)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        ç­‰å¾…æŒ‰éµçµæŸ        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Queue 
 æ˜¯ BFS çš„æ ¸å¿ƒçµæ§‹ï¼Œç”¨ä¾†å­˜æ”¾ä¸‹ä¸€æ­¥è¦æ¢ç´¢çš„ç¯€é»ã€‚

visited 
 ç”¨ä¾†é¿å…é‡è¤‡æ‹œè¨ªç¯€é»ã€‚

prev 
 ç”¨ä¾†è¨˜éŒ„è·¯å¾‘ï¼Œæ–¹ä¾¿åœ¨æ‰¾åˆ°çµ‚é»æ™‚å›æº¯å‡ºæœ€çŸ­è·¯å¾‘ã€‚

BFS 
 ä¸€å±¤å±¤å‘å¤–æ“´å±•ï¼Œç¢ºä¿ç¬¬ä¸€å€‹æ‰¾åˆ°çš„çµ‚é»æ˜¯æœ€çŸ­è·¯å¾‘ã€‚

--------------------------------------------------------
c# map dfs

â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ
S â—  â–‘ â–ˆ â–‘ â–‘ â–‘ â–‘ â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–ˆ
â–ˆ â—  â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ
â–ˆ â—  â–‘ â–‘ â–‘ â–ˆ â–‘ â–‘ â–‘ â–‘ â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ
â–ˆ â—  â–‘ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ
â–ˆ â—  â–‘ â–‘ â–‘ â–ˆ â—      â—    â–‘ â–‘ â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ â–‘ â–‘ â–‘ â–‘ â–‘ â–ˆ
â–ˆ â—  â–ˆ â–ˆ â–‘ â–ˆ â—  â–ˆ â–ˆ â—  â—  â—  â–‘ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ
â–ˆ â—    â–‘ â–ˆ â—â—â—  â—    â—  â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ
â–ˆ â–ˆ â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ â—  â–ˆ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ
â–ˆ â—â—â—  â—    â—        â–ˆ â—  â–‘ â–‘ â–‘ â–ˆ â–‘ â–‘ â–‘ â–‘ â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ
â–ˆ â—  â–ˆ â–ˆ â—  â—  â—    â–ˆ â–ˆ â–ˆ â—  â–‘ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ
â–ˆ â—    â—  â—  â—        â–ˆ â—  â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–‘ â–ˆ â–‘ â–ˆ â–‘ â–‘ â–‘ â–ˆ
â–ˆ â–ˆ â–ˆ â—  â—  â—  â—  â–ˆ â–ˆ   â–ˆ â—  â–ˆ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â–‘ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ â–‘ â–ˆ
â–ˆ   â–ˆ â—    â—  â—        â–ˆ â—  â—    â–‘ â–ˆ â–‘ â–‘ â–‘ â–‘ â–‘ â–ˆ â–‘ â–ˆ
â–ˆ   â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â—  â—    â–ˆ   â–ˆ â—  â—  â—  â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–‘ â–ˆ
â–ˆ           â–ˆ â—      â–ˆ   â–ˆ â—    â—  â—        â–‘ â–ˆ
â–ˆ â–ˆ â–ˆ   â–ˆ   â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ   â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â—  â—  â–ˆ â–ˆ â–ˆ â–ˆ â—  â–‘ â–ˆ
â–ˆ       â–ˆ   â–ˆ           â–ˆ           â–ˆ â—  â—    â–ˆ â—â—â—  â–‘ â–ˆ
â–ˆ   â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ   â–ˆ   â–ˆ â–ˆ â–ˆ   â–ˆ â–ˆ â–ˆ   â–ˆ â—  â—    â–ˆ â—  â–ˆ â–ˆ â–‘ â–ˆ
â–ˆ               â–ˆ               â–ˆ     â—        â—    G
â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ â–ˆ

ğŸ” æ­£åœ¨åŸ·è¡Œ DFS æ¢ç´¢è¿·å®®...

âœ… æ¢ç´¢å®Œæˆï¼ç¸½å…±æ¢ç´¢æ ¼æ•¸ï¼š237
â±ï¸ è€—æ™‚ï¼š7655 æ¯«ç§’
ğŸ”š æŒ‰ä»»æ„éµçµæŸ...


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Threading;

class AnimatedDFSWithStats
{
    const int width = 31;
    const int height = 21;
    static int[,] maze = new int[height, width];
    static Random rand = new Random();

    static (int y, int x) start = (1, 0);
    static (int y, int x) goal = (height - 2, width - 1);

    static bool[,] visited = new bool[height, width];
    static List<(int y, int x)> path = new List<(int y, int x)>();
    static int stepCount = 0;

    static void Main()
    {
        Console.OutputEncoding = Encoding.UTF8;
        Console.CursorVisible = false;

        GenerateMaze(1, 1);
        maze[start.y, start.x] = 1;
        maze[goal.y, goal.x] = 1;

        PrintMaze();

        Console.SetCursorPosition(0, height + 1);
        Console.WriteLine("ğŸ” æ­£åœ¨åŸ·è¡Œ DFS æ¢ç´¢è¿·å®®...");

        var sw = Stopwatch.StartNew();
        bool found = DFS(start.y, start.x);
        sw.Stop();

        if (found)
        {
            // ç¹ªè£½æœ€çµ‚è·¯å¾‘
            foreach (var pos in path)
            {
                if (pos != start && pos != goal)
                {
                    DrawAt(pos.x, pos.y, 'â—', ConsoleColor.Yellow);
                    Thread.Sleep(10);
                }
            }

            DrawAt(start.x, start.y, 'S', ConsoleColor.Green);
            DrawAt(goal.x, goal.y, 'G', ConsoleColor.Red);

            Console.SetCursorPosition(0, height + 3);
            Console.WriteLine($"âœ… æ¢ç´¢å®Œæˆï¼ç¸½å…±æ¢ç´¢æ ¼æ•¸ï¼š{stepCount}");
            Console.WriteLine($"â±ï¸ è€—æ™‚ï¼š{sw.ElapsedMilliseconds} æ¯«ç§’");
        }
        else
        {
            Console.SetCursorPosition(0, height + 3);
            Console.WriteLine("âŒ ç„¡æ³•æ‰¾åˆ°å‡ºå£ï¼");
        }

        Console.WriteLine("ğŸ”š æŒ‰ä»»æ„éµçµæŸ...");
        Console.ReadKey();
    }

    static bool DFS(int y, int x)
    {
        if (!InBounds(x, y) || maze[y, x] == 0 || visited[y, x])
            return false;

        stepCount++;
        visited[y, x] = true;

        if ((y, x) != start && (y, x) != goal)
            DrawAt(x, y, 'â–‘', ConsoleColor.Gray);

        Thread.Sleep(20); // å‹•ç•«é€Ÿåº¦èª¿æ•´

        if ((y, x) == goal)
        {
            path.Add((y, x));
            return true;
        }

        int[] dx = { 0, 1, 0, -1 };
        int[] dy = { -1, 0, 1, 0 };

        for (int i = 0; i < 4; i++)
        {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if (DFS(ny, nx))
            {
                path.Add((y, x));  // å›æº¯è·¯å¾‘
                return true;
            }
        }

        return false;
    }

    static void DrawAt(int x, int y, char symbol, ConsoleColor color)
    {
        Console.SetCursorPosition(x * 2, y);
        Console.ForegroundColor = color;
        Console.Write(symbol + " ");
        Console.ResetColor();
    }

    static void GenerateMaze(int x, int y)
    {
        maze[y, x] = 1;
        int[] dirs = { 0, 1, 2, 3 };
        Shuffle(dirs);

        foreach (int dir in dirs)
        {
            int dx = 0, dy = 0;
            switch (dir)
            {
                case 0: dx = 0; dy = -1; break;
                case 1: dx = 1; dy = 0; break;
                case 2: dx = 0; dy = 1; break;
                case 3: dx = -1; dy = 0; break;
            }

            int nx = x + dx * 2;
            int ny = y + dy * 2;

            if (InBounds(nx, ny) && maze[ny, nx] == 0)
            {
                maze[y + dy, x + dx] = 1;
                GenerateMaze(nx, ny);
            }
        }
    }

    static void Shuffle(int[] array)
    {
        for (int i = array.Length - 1; i > 0; i--)
        {
            int j = rand.Next(i + 1);
            (array[i], array[j]) = (array[j], array[i]);
        }
    }

    static bool InBounds(int x, int y)
    {
        return x >= 0 && x < width && y >= 0 && y < height;
    }

    static void PrintMaze()
    {
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if ((y, x) == start)
                {
                    Console.ForegroundColor = ConsoleColor.Green;
                    Console.Write("S ");
                    Console.ResetColor();
                }
                else if ((y, x) == goal)
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.Write("G ");
                    Console.ResetColor();
                }
                else if (maze[y, x] == 0)
                {
                    Console.ForegroundColor = ConsoleColor.DarkGray;
                    Console.Write("â–ˆ ");
                    Console.ResetColor();
                }
                else
                {
                    Console.Write("  ");
                }
            }
            Console.WriteLine();
        }
    }
}

--------------------------------------------------------------------------
 c#  map å„ªåŒ–

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Threading;

class AnimatedDFSWithColors
{
    const int width = 31;
    const int height = 21;
    static int[,] maze = new int[height, width];
    static Random rand = new Random();

    static (int y, int x) start = (1, 0);
    static (int y, int x) goal = (height - 2, width - 1);

    static bool[,] visited = new bool[height, width];
    static List<(int y, int x)> path = new List<(int y, int x)>();
    static int stepCount = 0;

    static void Main()
    {
        Console.OutputEncoding = Encoding.UTF8;
        Console.CursorVisible = false;

        GenerateMaze(1, 1);
        maze[start.y, start.x] = 1;
        maze[goal.y, goal.x] = 1;

        PrintMaze();

        Console.SetCursorPosition(0, height + 1);
        Console.WriteLine("ğŸ” æ­£åœ¨åŸ·è¡Œ DFS æ¢ç´¢è¿·å®®...");

        var sw = Stopwatch.StartNew();
        bool found = DFS(start.y, start.x);
        sw.Stop();

        if (found)
        {
            path.Reverse();
            foreach (var pos in path)
            {
                if (pos != start && pos != goal)
                {
                    DrawAt(pos.x, pos.y, "â– ", ConsoleColor.Yellow);
                    Thread.Sleep(60);
                }
            }

            DrawAt(start.x, start.y, "ğŸŸ¢", ConsoleColor.Green);
            DrawAt(goal.x, goal.y, "ğŸ”´", ConsoleColor.Red);

            Console.SetCursorPosition(0, height + 3);
            Console.WriteLine($"âœ… æ¢ç´¢å®Œæˆï¼ç¸½å…±æ¢ç´¢æ ¼æ•¸ï¼š{stepCount}");
            Console.WriteLine($"â±ï¸ è€—æ™‚ï¼š{sw.ElapsedMilliseconds} æ¯«ç§’");
        }
        else
        {
            Console.SetCursorPosition(0, height + 3);
            Console.WriteLine("âŒ ç„¡æ³•æ‰¾åˆ°å‡ºå£ï¼");
        }

        Console.WriteLine("ğŸ”š æŒ‰ä»»æ„éµçµæŸ...");
        Console.ReadKey();
    }

    static bool DFS(int y, int x)
    {
        if (!InBounds(x, y) || maze[y, x] == 0 || visited[y, x])
            return false;

        stepCount++;
        visited[y, x] = true;

        if ((y, x) != start && (y, x) != goal)
            DrawAt(x, y, "Â·", ConsoleColor.DarkGray);

        Thread.Sleep(40);

        if ((y, x) == goal)
        {
            path.Add((y, x));
            return true;
        }

        int[] dx = { 0, 1, 0, -1 };
        int[] dy = { -1, 0, 1, 0 };

        for (int i = 0; i < 4; i++)
        {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if (DFS(ny, nx))
            {
                path.Add((y, x));
                return true;
            }
        }

        return false;
    }

    static void DrawAt(int x, int y, string symbol, ConsoleColor color)
    {
        Console.SetCursorPosition(x * 2, y);
        Console.ForegroundColor = color;
        Console.Write(symbol + " ");
        Console.ResetColor();
    }

    static void GenerateMaze(int x, int y)
    {
        maze[y, x] = 1;
        int[] dirs = { 0, 1, 2, 3 };
        Shuffle(dirs);

        foreach (int dir in dirs)
        {
            int dx = 0, dy = 0;
            switch (dir)
            {
                case 0: dx = 0; dy = -1; break;
                case 1: dx = 1; dy = 0; break;
                case 2: dx = 0; dy = 1; break;
                case 3: dx = -1; dy = 0; break;
            }

            int nx = x + dx * 2;
            int ny = y + dy * 2;

            if (InBounds(nx, ny) && maze[ny, nx] == 0)
            {
                maze[y + dy, x + dx] = 1;
                GenerateMaze(nx, ny);
            }
        }
    }

    static void Shuffle(int[] array)
    {
        for (int i = array.Length - 1; i > 0; i--)
        {
            int j = rand.Next(i + 1);
            (array[i], array[j]) = (array[j], array[i]);
        }
    }

    static bool InBounds(int x, int y)
    {
        return x >= 0 && x < width && y >= 0 && y < height;
    }

    static void PrintMaze()
    {
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if ((y, x) == start)
                {
                    Console.ForegroundColor = ConsoleColor.Green;
                    Console.Write("ğŸŸ¢ ");
                    Console.ResetColor();
                }
                else if ((y, x) == goal)
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.Write("ğŸ”´ ");
                    Console.ResetColor();
                }
                else if (maze[y, x] == 0)
                {
                    Console.ForegroundColor = ConsoleColor.DarkGray;
                    Console.Write("â–ˆ ");
                    Console.ResetColor();
                }
                else
                {
                    Console.Write("  ");
                }
            }
            Console.WriteLine();
        }
    }
}
-------------------------------------------------------------------------------
c# a* map

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Threading;

class AnimatedAStarWithColors
{
    const int width = 31;
    const int height = 21;
    static int[,] maze = new int[height, width];
    static Random rand = new Random();

    static (int y, int x) start = (1, 0);
    static (int y, int x) goal = (height - 2, width - 1);

    static void Main()
    {
        Console.OutputEncoding = Encoding.UTF8;
        Console.CursorVisible = false;

        GenerateMaze(1, 1);
        maze[start.y, start.x] = 1;
        maze[goal.y, goal.x] = 1;

        PrintMaze();

        Console.SetCursorPosition(0, height + 1);
        Console.WriteLine("ğŸ” æ­£åœ¨åŸ·è¡Œ A* æ¢ç´¢è¿·å®®...");

        var sw = Stopwatch.StartNew();
        int steps = SolveMazeWithAStarAnimated(start, goal);
        sw.Stop();

        Console.SetCursorPosition(0, height + 3);
        if (steps > 0)
        {
            Console.WriteLine($"âœ… æ¢ç´¢å®Œæˆï¼ç¸½å…±æ¢ç´¢æ ¼æ•¸ï¼š{steps}");
            Console.WriteLine($"â±ï¸ è€—æ™‚ï¼š{sw.ElapsedMilliseconds} æ¯«ç§’");
        }
        else
        {
            Console.WriteLine("âŒ ç„¡æ³•æ‰¾åˆ°å‡ºå£ï¼");
        }
        Console.WriteLine("ğŸ”š æŒ‰ä»»æ„éµçµæŸ...");
        Console.ReadKey();
    }

    // A* ç¯€é»çµæ§‹
    class Node : IComparable<Node>
    {
        public int y, x;
        public int g; // å¾èµ·é»åˆ°æ­¤ç¯€é»çš„è·é›¢
        public int h; // å•Ÿç™¼å¼ä¼°åƒ¹è·é›¢åˆ°ç›®æ¨™
        public int f => g + h;
        public (int y, int x)? parent;

        public Node(int y, int x, int g, int h, (int y, int x)? parent)
        {
            this.y = y; this.x = x; this.g = g; this.h = h; this.parent = parent;
        }

        // SortedSet éœ€è¦æ¯”è¼ƒç¯€é»å¤§å°ï¼Œf å°çš„å„ªå…ˆ
        public int CompareTo(Node other)
        {
            int c = f.CompareTo(other.f);
            if (c == 0) c = h.CompareTo(other.h); // h å°å„ªå…ˆ
            if (c == 0)
            {
                c = y.CompareTo(other.y);
                if (c == 0) c = x.CompareTo(other.x);
            }
            return c;
        }

        public override bool Equals(object obj)
        {
            if (obj is Node other)
                return y == other.y && x == other.x;
            return false;
        }

        public override int GetHashCode()
        {
            return y * 1000 + x;
        }
    }

    static int SolveMazeWithAStarAnimated((int y, int x) start, (int y, int x) goal)
    {
        var openSet = new SortedSet<Node>();
        var cameFrom = new (int y, int x)?[height, width];
        var gScore = new int[height, width];
        var visited = new bool[height, width];

        for (int i = 0; i < height; i++)
            for (int j = 0; j < width; j++)
                gScore[i, j] = int.MaxValue;

        int Heuristic(int y, int x)
        {
            return Math.Abs(goal.y - y) + Math.Abs(goal.x - x);
        }

        var startNode = new Node(start.y, start.x, 0, Heuristic(start.y, start.x), null);
        openSet.Add(startNode);
        gScore[start.y, start.x] = 0;

        int stepCount = 0;

        int[] dx = { 0, 1, 0, -1 };
        int[] dy = { -1, 0, 1, 0 };

        while (openSet.Count > 0)
        {
            var current = openSet.Min;
            openSet.Remove(current);

            stepCount++;
            visited[current.y, current.x] = true;

            if ((current.y, current.x) != start && (current.y, current.x) != goal)
                DrawAt(current.x, current.y, "Â·", ConsoleColor.DarkGray);

            Thread.Sleep(30);

            if (current.y == goal.y && current.x == goal.x)
            {
                // å›æº¯è·¯å¾‘
                var path = new List<(int y, int x)>();
                var c = current;
                while (c.parent != null)
                {
                    path.Add((c.y, c.x));
                    c = new Node(c.parent.Value.y, c.parent.Value.x, 0, 0, cameFrom[c.y, c.x]);
                }
                path.Add(start);
                path.Reverse();

                foreach (var pos in path)
                {
                    if (pos != start && pos != goal)
                    {
                        DrawAt(pos.x, pos.y, "â– ", ConsoleColor.Yellow);
                        Thread.Sleep(60);
                    }
                }
                DrawAt(start.x, start.y, "ğŸŸ¢", ConsoleColor.Green);
                DrawAt(goal.x, goal.y, "ğŸ”´", ConsoleColor.Red);

                return stepCount;
            }

            for (int i = 0; i < 4; i++)
            {
                int nx = current.x + dx[i];
                int ny = current.y + dy[i];
                if (!InBounds(nx, ny) || maze[ny, nx] == 0)
                    continue;
                if (visited[ny, nx])
                    continue;

                int tentative_gScore = gScore[current.y, current.x] + 1;
                if (tentative_gScore < gScore[ny, nx])
                {
                    cameFrom[ny, nx] = (current.y, current.x);
                    gScore[ny, nx] = tentative_gScore;
                    var neighbor = new Node(ny, nx, tentative_gScore, Heuristic(ny, nx), (current.y, current.x));
                    if (openSet.Contains(neighbor))
                    {
                        openSet.Remove(neighbor);
                    }
                    openSet.Add(neighbor);
                }
            }
        }

        return 0; // ç„¡è§£
    }

    static void DrawAt(int x, int y, string symbol, ConsoleColor color)
    {
        Console.SetCursorPosition(x * 2, y);
        Console.ForegroundColor = color;
        Console.Write(symbol + " ");
        Console.ResetColor();
    }

    static void GenerateMaze(int x, int y)
    {
        maze[y, x] = 1;
        int[] dirs = { 0, 1, 2, 3 };
        Shuffle(dirs);

        foreach (int dir in dirs)
        {
            int dx = 0, dy = 0;
            switch (dir)
            {
                case 0: dx = 0; dy = -1; break;
                case 1: dx = 1; dy = 0; break;
                case 2: dx = 0; dy = 1; break;
                case 3: dx = -1; dy = 0; break;
            }

            int nx = x + dx * 2;
            int ny = y + dy * 2;

            if (InBounds(nx, ny) && maze[ny, nx] == 0)
            {
                maze[y + dy, x + dx] = 1;
                GenerateMaze(nx, ny);
            }
        }
    }

    static void Shuffle(int[] array)
    {
        for (int i = array.Length - 1; i > 0; i--)
        {
            int j = rand.Next(i + 1);
            (array[i], array[j]) = (array[j], array[i]);
        }
    }

    static bool InBounds(int x, int y)
    {
        return x >= 0 && x < width && y >= 0 && y < height;
    }

    static void PrintMaze()
    {
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                if ((y, x) == start)
                {
                    Console.ForegroundColor = ConsoleColor.Green;
                    Console.Write("ğŸŸ¢ ");
                    Console.ResetColor();
                }
                else if ((y, x) == goal)
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.Write("ğŸ”´ ");
                    Console.ResetColor();
                }
                else if (maze[y, x] == 0)
                {
                    Console.ForegroundColor = ConsoleColor.DarkGray;
                    Console.Write("â–ˆ ");
                    Console.ResetColor();
                }
                else
                {
                    Console.Write("  ");
                }
            }
            Console.WriteLine();
        }
    }
}

è¦è§£è¿·å®®ï¼Œé‚„æ˜¯ç”¨ BFSã€DFSã€A* æœ€åˆé©ã€‚

æ¼”ç®—æ³•	æ™‚é–“ (ç´„)					è¨˜æ†¶é«” (ç´„)					æœ€çŸ­è·¯å¾‘ä¿è­‰	å‚™è¨»
BFS		O(V+E)ï¼Œå±¤å±¤å±•é–‹			é«˜ï¼ˆæ•´å±¤ç¯€é»ï¼‰				æ˜¯				æœ€çŸ­è·¯å¾‘ï¼Œè¨˜æ†¶é«”æ¶ˆè€—è¼ƒå¤§
DFS		O(V+E)ï¼Œæ·±åº¦å„ªå…ˆæ¢ç´¢		ä½ï¼ˆæœ€å¤§éè¿´æ·±åº¦ï¼‰			å¦				å¯èƒ½ç¹é è·¯ï¼Œè¨˜æ†¶é«”è¼ƒçœ
A*		O(V+E)ï¼Œä¾å•Ÿç™¼å¼æ•ˆç‡æ±ºå®š	ä¸­é«˜ï¼ˆç¯€é»ç‹€æ…‹ã€å„ªå…ˆä½‡åˆ—ï¼‰	æ˜¯				å•Ÿç™¼å¼å¥½æ•ˆèƒ½é«˜ï¼Œéœ€æ›´å¤šè³‡è¨Šå„²å­˜

æ¼”ç®—æ³•		å»ºè­°æ‡‰ç”¨å ´æ™¯							æ³¨æ„äº‹é …
BFS			å°å‹è¿·å®®æˆ–éœ€è¦æœ€çŸ­è·¯å¾‘					å¯èƒ½ç”¨è¼ƒå¤šè¨˜æ†¶é«”ï¼Œè¶…å¤§è¿·å®®è¼ƒæ…¢
DFS			å¤§å‹è¿·å®®æˆ–è¨˜æ†¶é«”æœ‰é™æƒ…æ³				æ‰¾åˆ°è·¯å¾‘ä½†ä¸ä¸€å®šæ˜¯æœ€çŸ­ï¼Œå¯èƒ½èµ°å†¤æ‰è·¯
A*			ä¸­å¤§å‹è¿·å®®ï¼Œæœ‰åˆé©å•Ÿç™¼å¼ï¼ˆheuristicï¼‰	éœ€è¦è¨ˆç®—å•Ÿç™¼å‡½æ•¸ï¼Œå¯¦ä½œè¼ƒè¤‡é›œ

